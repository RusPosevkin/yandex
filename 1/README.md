# Сортировщик карточек путешественника

# [Демо](http://posevkin.ru/yandex/travel-cards/demo/demo.html "Travel Cards Sorter Demo")

## Формат входных данных

API принимает на вход массив объектов. В каждом объекте обязательно должны быть указаны поля `departure` и `destination`. При этом в рамках одной карточки значения `departure` и `destination` не должны совпадать.

Возможно указание типа транспорта, с помощью которого осуществляется передвижение по данному маршруту. В настоящий момент реализованы шаблоны для следующих видов транспорта: train, bus, plane, taxi. При отсутствии вида транспорта, используется стандартный шаблон (From point_a to point_b.)

В качестве дополнительной информации возможно указать номер рейса `transport.route`, номер места `transport.seat`, выход на посадку `transport.gate`, дополнительная информация относительно автомобиля такcи `transport.info`. Необходимость сдачи багажа во время авиаперелета определяется параметром `transport.baggage_drop`. Возможен вариант автоматического трансфера багажа на пересадочном рейсе (`transport.baggage_drop.required = false`), либо будет указан номер стойки для сдачи багажа (`transport.baggage_drop.value`).

Пример входных данных:

```
[
    {
        departure: "Stockholm",
        destination: "New York JFK",
        transport: {
            type: "plane",
            route: "SK22",
            seat: "7B",
            gate: "22",
            baggage_drop: {
                required: false
            }
        }
    },
    {
        departure: "Barcelona",
        destination: "Gerona Airport",
        transport: {
            type: "bus",
            route: "airport",
            seat: false
        }
    },
    {
        departure: "Gerona Airport",
        destination: "Stockholm",
        transport: {
            type: "plane",
            route: "SK455",
            seat: "3A",
            gate: "45B",
            baggage_drop: {
                required: true,
                value: "344"
            }
        }
    },
    {
        departure: "Madrid",
        destination: "Barcelona",
        transport: {
            type: "train",
            route: "78A",
            seat: "45B"
        }
    }
];
```



### Использование

```
var tcs = new TravelCardsSorter(data);
tcs.sort();
tcs.printRoute();
```

### Замкнутая цепочка
По условию задания "Алгоритм должен работать с любым количеством карточек, если все карточки образуют одну неразрывную цепочку." При этом возможна ситуация так называемой "замкнутой цепочки", когда начальная и конечная точка совпадают.

Пример набора карточек, образующих замкнутую цепочку:
```
[
    {
        departure: "D",
        destination: "A"
    },
    {
        departure: "B",
        destination: "C"
    },
    {
        departure: "C",
        destination: "D"
    },
    {
        departure: "A",
        destination: "B"
    }
];
```
Т.к. "время прибытия и отправления неизвестно и не важно", то в текущих условиях невозможно достоверно определить начальную точку маршрута. В подобной ситуации за начальную принимается точка отправления из первой импортированной карточки.

#### TravelCardsSorter(data)
Метод-конструктор. На вход может принимать необязательный параметр `data`. В этом случае будут импортированы карточки с помощью метода `this.importData`.

#### TravelCardsSorter.importCards(data)
Метод импортирует карточки путешественника `data`. Возвращает количество импортированных карточек, сами карточки хранятся в `this.cards`.
Также производится проверка корректности формата представленных данных (`data` - массив, поля `departure` и `destination` определены и не совпадают в рамках одной карточки).

#### TravelCardsSorter.createHashTable()
Вспомогательный метод, формирующий хеш-таблицу, где ключ — точка отправления или прибытия, значение — объект с полями `departure` и `destination` содержащих числовое значение частоты вхождения точки в массив карточек в качестве точки отправления или прибытия:
![alt text](http://posevkin.ru/yandex/hashtable.png "Hashtable")
Хранится хеш-таблица в `this.points`.

#### TravelCardsSorter.getEndPoints()
Метод определяет начальную и конечную точки маршрута с использованием ранее созданной хеш-таблицы `this.points`. Также анализируется, возможно ли составить цепочку из импортированных карточек. Если единая цепочка не образуется — генерируется ошибка.

#### TravelCardsSorter.makeChain(endPoints)
Метод принимает на вход начальную и конечную точки маршрута и исходя из этих данных начинает разворачивать полную цепочку от начала к концу. При этом возможна ситуация, когда во время путешествия образуются зацикливания и происходит возврат в точку, в которой мы уже были раньше. В таком случае из данной точки можно проложить дальнейший путь несколькими альтернативными способами. Решением проблемы является построение дальнейшего маршрута до тех пор, пока не придем в конечную точку. Попав в конечную точку, необходимо проверить, что длина маршрута соответствует количеству импортированных карточек путешественника. Если это не так, то необходимо вернуться обратно по дереву решений до предыдущей точки с несколькими альтернативными вариантами и начать разворачивать следующий альтернативный вариант. Все это происходит до тех пор, пока мы не окажемся в конечной точке и длина пути будет соответствовать количеству импортированных карточек.

#### TravelCardsSorter.sort()
Метод сортировки, последовательно вызывающий функции `this.createHashTable()`, `this.getEndPoints()` и `this.makeChain()`. Отсортированная цепочка хранится в `this.sortedData`.

#### TravelCardsSorter.printRoute()
Метод на основе шаблонов возвращает html разметку с последовательным словесным описанием маршрута. При этом, если вызвать метод до вызова метода `this.sort()` будет выведено описание маршрута в исходном неотсортированном виде.